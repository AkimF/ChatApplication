// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chatserver.proto

#ifndef PROTOBUF_chatserver_2eproto__INCLUDED
#define PROTOBUF_chatserver_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace chatserver {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_chatserver_2eproto();
void protobuf_AssignDesc_chatserver_2eproto();
void protobuf_ShutdownFile_chatserver_2eproto();

class ListM;
class ListReply;
class ListRequest;
class LogInM;
class LogInReply;
class LogInRequest;
class LogOutM;
class LogOutReply;
class LogOutRequest;
class ReceiveMessageM;
class ReceiveMessageReply;
class ReceiveMessageRequest;
class SendMessageM;
class SendMessageReply;
class SendMessageRequest;
class oneOfTypes;

// ===================================================================

class LogInRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chatserver.LogInRequest) */ {
 public:
  LogInRequest();
  virtual ~LogInRequest();

  LogInRequest(const LogInRequest& from);

  inline LogInRequest& operator=(const LogInRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogInRequest& default_instance();

  void Swap(LogInRequest* other);

  // implements Message ----------------------------------------------

  inline LogInRequest* New() const { return New(NULL); }

  LogInRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogInRequest& from);
  void MergeFrom(const LogInRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LogInRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string user = 1;
  void clear_user();
  static const int kUserFieldNumber = 1;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // @@protoc_insertion_point(class_scope:chatserver.LogInRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chatserver_2eproto();
  friend void protobuf_AssignDesc_chatserver_2eproto();
  friend void protobuf_ShutdownFile_chatserver_2eproto();

  void InitAsDefaultInstance();
  static LogInRequest* default_instance_;
};
// -------------------------------------------------------------------

class LogInReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chatserver.LogInReply) */ {
 public:
  LogInReply();
  virtual ~LogInReply();

  LogInReply(const LogInReply& from);

  inline LogInReply& operator=(const LogInReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogInReply& default_instance();

  void Swap(LogInReply* other);

  // implements Message ----------------------------------------------

  inline LogInReply* New() const { return New(NULL); }

  LogInReply* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogInReply& from);
  void MergeFrom(const LogInReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LogInReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string conformation = 1;
  void clear_conformation();
  static const int kConformationFieldNumber = 1;
  const ::std::string& conformation() const;
  void set_conformation(const ::std::string& value);
  void set_conformation(const char* value);
  void set_conformation(const char* value, size_t size);
  ::std::string* mutable_conformation();
  ::std::string* release_conformation();
  void set_allocated_conformation(::std::string* conformation);

  // @@protoc_insertion_point(class_scope:chatserver.LogInReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr conformation_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chatserver_2eproto();
  friend void protobuf_AssignDesc_chatserver_2eproto();
  friend void protobuf_ShutdownFile_chatserver_2eproto();

  void InitAsDefaultInstance();
  static LogInReply* default_instance_;
};
// -------------------------------------------------------------------

class LogOutRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chatserver.LogOutRequest) */ {
 public:
  LogOutRequest();
  virtual ~LogOutRequest();

  LogOutRequest(const LogOutRequest& from);

  inline LogOutRequest& operator=(const LogOutRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogOutRequest& default_instance();

  void Swap(LogOutRequest* other);

  // implements Message ----------------------------------------------

  inline LogOutRequest* New() const { return New(NULL); }

  LogOutRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogOutRequest& from);
  void MergeFrom(const LogOutRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LogOutRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string user = 1;
  void clear_user();
  static const int kUserFieldNumber = 1;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // @@protoc_insertion_point(class_scope:chatserver.LogOutRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chatserver_2eproto();
  friend void protobuf_AssignDesc_chatserver_2eproto();
  friend void protobuf_ShutdownFile_chatserver_2eproto();

  void InitAsDefaultInstance();
  static LogOutRequest* default_instance_;
};
// -------------------------------------------------------------------

class LogOutReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chatserver.LogOutReply) */ {
 public:
  LogOutReply();
  virtual ~LogOutReply();

  LogOutReply(const LogOutReply& from);

  inline LogOutReply& operator=(const LogOutReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogOutReply& default_instance();

  void Swap(LogOutReply* other);

  // implements Message ----------------------------------------------

  inline LogOutReply* New() const { return New(NULL); }

  LogOutReply* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogOutReply& from);
  void MergeFrom(const LogOutReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LogOutReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string conformation = 1;
  void clear_conformation();
  static const int kConformationFieldNumber = 1;
  const ::std::string& conformation() const;
  void set_conformation(const ::std::string& value);
  void set_conformation(const char* value);
  void set_conformation(const char* value, size_t size);
  ::std::string* mutable_conformation();
  ::std::string* release_conformation();
  void set_allocated_conformation(::std::string* conformation);

  // @@protoc_insertion_point(class_scope:chatserver.LogOutReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr conformation_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chatserver_2eproto();
  friend void protobuf_AssignDesc_chatserver_2eproto();
  friend void protobuf_ShutdownFile_chatserver_2eproto();

  void InitAsDefaultInstance();
  static LogOutReply* default_instance_;
};
// -------------------------------------------------------------------

class SendMessageRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chatserver.SendMessageRequest) */ {
 public:
  SendMessageRequest();
  virtual ~SendMessageRequest();

  SendMessageRequest(const SendMessageRequest& from);

  inline SendMessageRequest& operator=(const SendMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SendMessageRequest& default_instance();

  void Swap(SendMessageRequest* other);

  // implements Message ----------------------------------------------

  inline SendMessageRequest* New() const { return New(NULL); }

  SendMessageRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendMessageRequest& from);
  void MergeFrom(const SendMessageRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SendMessageRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string user = 1;
  void clear_user();
  static const int kUserFieldNumber = 1;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // optional string recipient = 2;
  void clear_recipient();
  static const int kRecipientFieldNumber = 2;
  const ::std::string& recipient() const;
  void set_recipient(const ::std::string& value);
  void set_recipient(const char* value);
  void set_recipient(const char* value, size_t size);
  ::std::string* mutable_recipient();
  ::std::string* release_recipient();
  void set_allocated_recipient(::std::string* recipient);

  // optional string message = 3;
  void clear_message();
  static const int kMessageFieldNumber = 3;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:chatserver.SendMessageRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  ::google::protobuf::internal::ArenaStringPtr recipient_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chatserver_2eproto();
  friend void protobuf_AssignDesc_chatserver_2eproto();
  friend void protobuf_ShutdownFile_chatserver_2eproto();

  void InitAsDefaultInstance();
  static SendMessageRequest* default_instance_;
};
// -------------------------------------------------------------------

class SendMessageReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chatserver.SendMessageReply) */ {
 public:
  SendMessageReply();
  virtual ~SendMessageReply();

  SendMessageReply(const SendMessageReply& from);

  inline SendMessageReply& operator=(const SendMessageReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SendMessageReply& default_instance();

  void Swap(SendMessageReply* other);

  // implements Message ----------------------------------------------

  inline SendMessageReply* New() const { return New(NULL); }

  SendMessageReply* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendMessageReply& from);
  void MergeFrom(const SendMessageReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SendMessageReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string conformation = 1;
  void clear_conformation();
  static const int kConformationFieldNumber = 1;
  const ::std::string& conformation() const;
  void set_conformation(const ::std::string& value);
  void set_conformation(const char* value);
  void set_conformation(const char* value, size_t size);
  ::std::string* mutable_conformation();
  ::std::string* release_conformation();
  void set_allocated_conformation(::std::string* conformation);

  // @@protoc_insertion_point(class_scope:chatserver.SendMessageReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr conformation_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chatserver_2eproto();
  friend void protobuf_AssignDesc_chatserver_2eproto();
  friend void protobuf_ShutdownFile_chatserver_2eproto();

  void InitAsDefaultInstance();
  static SendMessageReply* default_instance_;
};
// -------------------------------------------------------------------

class ReceiveMessageRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chatserver.ReceiveMessageRequest) */ {
 public:
  ReceiveMessageRequest();
  virtual ~ReceiveMessageRequest();

  ReceiveMessageRequest(const ReceiveMessageRequest& from);

  inline ReceiveMessageRequest& operator=(const ReceiveMessageRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReceiveMessageRequest& default_instance();

  void Swap(ReceiveMessageRequest* other);

  // implements Message ----------------------------------------------

  inline ReceiveMessageRequest* New() const { return New(NULL); }

  ReceiveMessageRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReceiveMessageRequest& from);
  void MergeFrom(const ReceiveMessageRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReceiveMessageRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string user = 1;
  void clear_user();
  static const int kUserFieldNumber = 1;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // @@protoc_insertion_point(class_scope:chatserver.ReceiveMessageRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chatserver_2eproto();
  friend void protobuf_AssignDesc_chatserver_2eproto();
  friend void protobuf_ShutdownFile_chatserver_2eproto();

  void InitAsDefaultInstance();
  static ReceiveMessageRequest* default_instance_;
};
// -------------------------------------------------------------------

class ReceiveMessageReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chatserver.ReceiveMessageReply) */ {
 public:
  ReceiveMessageReply();
  virtual ~ReceiveMessageReply();

  ReceiveMessageReply(const ReceiveMessageReply& from);

  inline ReceiveMessageReply& operator=(const ReceiveMessageReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReceiveMessageReply& default_instance();

  void Swap(ReceiveMessageReply* other);

  // implements Message ----------------------------------------------

  inline ReceiveMessageReply* New() const { return New(NULL); }

  ReceiveMessageReply* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReceiveMessageReply& from);
  void MergeFrom(const ReceiveMessageReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReceiveMessageReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string conformation = 1;
  void clear_conformation();
  static const int kConformationFieldNumber = 1;
  const ::std::string& conformation() const;
  void set_conformation(const ::std::string& value);
  void set_conformation(const char* value);
  void set_conformation(const char* value, size_t size);
  ::std::string* mutable_conformation();
  ::std::string* release_conformation();
  void set_allocated_conformation(::std::string* conformation);

  // @@protoc_insertion_point(class_scope:chatserver.ReceiveMessageReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr conformation_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chatserver_2eproto();
  friend void protobuf_AssignDesc_chatserver_2eproto();
  friend void protobuf_ShutdownFile_chatserver_2eproto();

  void InitAsDefaultInstance();
  static ReceiveMessageReply* default_instance_;
};
// -------------------------------------------------------------------

class ListRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chatserver.ListRequest) */ {
 public:
  ListRequest();
  virtual ~ListRequest();

  ListRequest(const ListRequest& from);

  inline ListRequest& operator=(const ListRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListRequest& default_instance();

  void Swap(ListRequest* other);

  // implements Message ----------------------------------------------

  inline ListRequest* New() const { return New(NULL); }

  ListRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListRequest& from);
  void MergeFrom(const ListRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string list = 1;
  void clear_list();
  static const int kListFieldNumber = 1;
  const ::std::string& list() const;
  void set_list(const ::std::string& value);
  void set_list(const char* value);
  void set_list(const char* value, size_t size);
  ::std::string* mutable_list();
  ::std::string* release_list();
  void set_allocated_list(::std::string* list);

  // @@protoc_insertion_point(class_scope:chatserver.ListRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr list_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chatserver_2eproto();
  friend void protobuf_AssignDesc_chatserver_2eproto();
  friend void protobuf_ShutdownFile_chatserver_2eproto();

  void InitAsDefaultInstance();
  static ListRequest* default_instance_;
};
// -------------------------------------------------------------------

class ListReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chatserver.ListReply) */ {
 public:
  ListReply();
  virtual ~ListReply();

  ListReply(const ListReply& from);

  inline ListReply& operator=(const ListReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListReply& default_instance();

  void Swap(ListReply* other);

  // implements Message ----------------------------------------------

  inline ListReply* New() const { return New(NULL); }

  ListReply* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListReply& from);
  void MergeFrom(const ListReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string list = 1;
  void clear_list();
  static const int kListFieldNumber = 1;
  const ::std::string& list() const;
  void set_list(const ::std::string& value);
  void set_list(const char* value);
  void set_list(const char* value, size_t size);
  ::std::string* mutable_list();
  ::std::string* release_list();
  void set_allocated_list(::std::string* list);

  // @@protoc_insertion_point(class_scope:chatserver.ListReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr list_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chatserver_2eproto();
  friend void protobuf_AssignDesc_chatserver_2eproto();
  friend void protobuf_ShutdownFile_chatserver_2eproto();

  void InitAsDefaultInstance();
  static ListReply* default_instance_;
};
// -------------------------------------------------------------------

class ListM : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chatserver.ListM) */ {
 public:
  ListM();
  virtual ~ListM();

  ListM(const ListM& from);

  inline ListM& operator=(const ListM& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListM& default_instance();

  void Swap(ListM* other);

  // implements Message ----------------------------------------------

  inline ListM* New() const { return New(NULL); }

  ListM* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ListM& from);
  void MergeFrom(const ListM& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ListM* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .chatserver.ListReply reply = 1;
  bool has_reply() const;
  void clear_reply();
  static const int kReplyFieldNumber = 1;
  const ::chatserver::ListReply& reply() const;
  ::chatserver::ListReply* mutable_reply();
  ::chatserver::ListReply* release_reply();
  void set_allocated_reply(::chatserver::ListReply* reply);

  // optional .chatserver.ListRequest request = 2;
  bool has_request() const;
  void clear_request();
  static const int kRequestFieldNumber = 2;
  const ::chatserver::ListRequest& request() const;
  ::chatserver::ListRequest* mutable_request();
  ::chatserver::ListRequest* release_request();
  void set_allocated_request(::chatserver::ListRequest* request);

  // @@protoc_insertion_point(class_scope:chatserver.ListM)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::chatserver::ListReply* reply_;
  ::chatserver::ListRequest* request_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chatserver_2eproto();
  friend void protobuf_AssignDesc_chatserver_2eproto();
  friend void protobuf_ShutdownFile_chatserver_2eproto();

  void InitAsDefaultInstance();
  static ListM* default_instance_;
};
// -------------------------------------------------------------------

class ReceiveMessageM : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chatserver.ReceiveMessageM) */ {
 public:
  ReceiveMessageM();
  virtual ~ReceiveMessageM();

  ReceiveMessageM(const ReceiveMessageM& from);

  inline ReceiveMessageM& operator=(const ReceiveMessageM& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReceiveMessageM& default_instance();

  void Swap(ReceiveMessageM* other);

  // implements Message ----------------------------------------------

  inline ReceiveMessageM* New() const { return New(NULL); }

  ReceiveMessageM* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReceiveMessageM& from);
  void MergeFrom(const ReceiveMessageM& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReceiveMessageM* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .chatserver.ReceiveMessageReply reply = 1;
  bool has_reply() const;
  void clear_reply();
  static const int kReplyFieldNumber = 1;
  const ::chatserver::ReceiveMessageReply& reply() const;
  ::chatserver::ReceiveMessageReply* mutable_reply();
  ::chatserver::ReceiveMessageReply* release_reply();
  void set_allocated_reply(::chatserver::ReceiveMessageReply* reply);

  // optional .chatserver.ReceiveMessageRequest request = 2;
  bool has_request() const;
  void clear_request();
  static const int kRequestFieldNumber = 2;
  const ::chatserver::ReceiveMessageRequest& request() const;
  ::chatserver::ReceiveMessageRequest* mutable_request();
  ::chatserver::ReceiveMessageRequest* release_request();
  void set_allocated_request(::chatserver::ReceiveMessageRequest* request);

  // @@protoc_insertion_point(class_scope:chatserver.ReceiveMessageM)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::chatserver::ReceiveMessageReply* reply_;
  ::chatserver::ReceiveMessageRequest* request_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chatserver_2eproto();
  friend void protobuf_AssignDesc_chatserver_2eproto();
  friend void protobuf_ShutdownFile_chatserver_2eproto();

  void InitAsDefaultInstance();
  static ReceiveMessageM* default_instance_;
};
// -------------------------------------------------------------------

class SendMessageM : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chatserver.SendMessageM) */ {
 public:
  SendMessageM();
  virtual ~SendMessageM();

  SendMessageM(const SendMessageM& from);

  inline SendMessageM& operator=(const SendMessageM& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SendMessageM& default_instance();

  void Swap(SendMessageM* other);

  // implements Message ----------------------------------------------

  inline SendMessageM* New() const { return New(NULL); }

  SendMessageM* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendMessageM& from);
  void MergeFrom(const SendMessageM& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SendMessageM* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .chatserver.SendMessageReply reply = 1;
  bool has_reply() const;
  void clear_reply();
  static const int kReplyFieldNumber = 1;
  const ::chatserver::SendMessageReply& reply() const;
  ::chatserver::SendMessageReply* mutable_reply();
  ::chatserver::SendMessageReply* release_reply();
  void set_allocated_reply(::chatserver::SendMessageReply* reply);

  // optional .chatserver.SendMessageRequest request = 2;
  bool has_request() const;
  void clear_request();
  static const int kRequestFieldNumber = 2;
  const ::chatserver::SendMessageRequest& request() const;
  ::chatserver::SendMessageRequest* mutable_request();
  ::chatserver::SendMessageRequest* release_request();
  void set_allocated_request(::chatserver::SendMessageRequest* request);

  // @@protoc_insertion_point(class_scope:chatserver.SendMessageM)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::chatserver::SendMessageReply* reply_;
  ::chatserver::SendMessageRequest* request_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chatserver_2eproto();
  friend void protobuf_AssignDesc_chatserver_2eproto();
  friend void protobuf_ShutdownFile_chatserver_2eproto();

  void InitAsDefaultInstance();
  static SendMessageM* default_instance_;
};
// -------------------------------------------------------------------

class LogInM : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chatserver.LogInM) */ {
 public:
  LogInM();
  virtual ~LogInM();

  LogInM(const LogInM& from);

  inline LogInM& operator=(const LogInM& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogInM& default_instance();

  void Swap(LogInM* other);

  // implements Message ----------------------------------------------

  inline LogInM* New() const { return New(NULL); }

  LogInM* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogInM& from);
  void MergeFrom(const LogInM& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LogInM* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .chatserver.LogInReply reply = 1;
  bool has_reply() const;
  void clear_reply();
  static const int kReplyFieldNumber = 1;
  const ::chatserver::LogInReply& reply() const;
  ::chatserver::LogInReply* mutable_reply();
  ::chatserver::LogInReply* release_reply();
  void set_allocated_reply(::chatserver::LogInReply* reply);

  // optional .chatserver.LogInRequest request = 2;
  bool has_request() const;
  void clear_request();
  static const int kRequestFieldNumber = 2;
  const ::chatserver::LogInRequest& request() const;
  ::chatserver::LogInRequest* mutable_request();
  ::chatserver::LogInRequest* release_request();
  void set_allocated_request(::chatserver::LogInRequest* request);

  // @@protoc_insertion_point(class_scope:chatserver.LogInM)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::chatserver::LogInReply* reply_;
  ::chatserver::LogInRequest* request_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chatserver_2eproto();
  friend void protobuf_AssignDesc_chatserver_2eproto();
  friend void protobuf_ShutdownFile_chatserver_2eproto();

  void InitAsDefaultInstance();
  static LogInM* default_instance_;
};
// -------------------------------------------------------------------

class LogOutM : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chatserver.LogOutM) */ {
 public:
  LogOutM();
  virtual ~LogOutM();

  LogOutM(const LogOutM& from);

  inline LogOutM& operator=(const LogOutM& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogOutM& default_instance();

  void Swap(LogOutM* other);

  // implements Message ----------------------------------------------

  inline LogOutM* New() const { return New(NULL); }

  LogOutM* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogOutM& from);
  void MergeFrom(const LogOutM& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LogOutM* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .chatserver.LogOutReply reply = 1;
  bool has_reply() const;
  void clear_reply();
  static const int kReplyFieldNumber = 1;
  const ::chatserver::LogOutReply& reply() const;
  ::chatserver::LogOutReply* mutable_reply();
  ::chatserver::LogOutReply* release_reply();
  void set_allocated_reply(::chatserver::LogOutReply* reply);

  // optional .chatserver.LogOutRequest request = 2;
  bool has_request() const;
  void clear_request();
  static const int kRequestFieldNumber = 2;
  const ::chatserver::LogOutRequest& request() const;
  ::chatserver::LogOutRequest* mutable_request();
  ::chatserver::LogOutRequest* release_request();
  void set_allocated_request(::chatserver::LogOutRequest* request);

  // @@protoc_insertion_point(class_scope:chatserver.LogOutM)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::chatserver::LogOutReply* reply_;
  ::chatserver::LogOutRequest* request_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_chatserver_2eproto();
  friend void protobuf_AssignDesc_chatserver_2eproto();
  friend void protobuf_ShutdownFile_chatserver_2eproto();

  void InitAsDefaultInstance();
  static LogOutM* default_instance_;
};
// -------------------------------------------------------------------

class oneOfTypes : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chatserver.oneOfTypes) */ {
 public:
  oneOfTypes();
  virtual ~oneOfTypes();

  oneOfTypes(const oneOfTypes& from);

  inline oneOfTypes& operator=(const oneOfTypes& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const oneOfTypes& default_instance();

  enum TypesCase {
    kLogout = 1,
    kLogin = 2,
    kSendmessage = 3,
    kReceivemessage = 4,
    kList = 5,
    TYPES_NOT_SET = 0,
  };

  void Swap(oneOfTypes* other);

  // implements Message ----------------------------------------------

  inline oneOfTypes* New() const { return New(NULL); }

  oneOfTypes* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const oneOfTypes& from);
  void MergeFrom(const oneOfTypes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(oneOfTypes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .chatserver.LogOutM logout = 1;
  bool has_logout() const;
  void clear_logout();
  static const int kLogoutFieldNumber = 1;
  const ::chatserver::LogOutM& logout() const;
  ::chatserver::LogOutM* mutable_logout();
  ::chatserver::LogOutM* release_logout();
  void set_allocated_logout(::chatserver::LogOutM* logout);

  // optional .chatserver.LogInM login = 2;
  bool has_login() const;
  void clear_login();
  static const int kLoginFieldNumber = 2;
  const ::chatserver::LogInM& login() const;
  ::chatserver::LogInM* mutable_login();
  ::chatserver::LogInM* release_login();
  void set_allocated_login(::chatserver::LogInM* login);

  // optional .chatserver.SendMessageM sendmessage = 3;
  bool has_sendmessage() const;
  void clear_sendmessage();
  static const int kSendmessageFieldNumber = 3;
  const ::chatserver::SendMessageM& sendmessage() const;
  ::chatserver::SendMessageM* mutable_sendmessage();
  ::chatserver::SendMessageM* release_sendmessage();
  void set_allocated_sendmessage(::chatserver::SendMessageM* sendmessage);

  // optional .chatserver.ReceiveMessageM receivemessage = 4;
  bool has_receivemessage() const;
  void clear_receivemessage();
  static const int kReceivemessageFieldNumber = 4;
  const ::chatserver::ReceiveMessageM& receivemessage() const;
  ::chatserver::ReceiveMessageM* mutable_receivemessage();
  ::chatserver::ReceiveMessageM* release_receivemessage();
  void set_allocated_receivemessage(::chatserver::ReceiveMessageM* receivemessage);

  // optional .chatserver.ListM list = 5;
  bool has_list() const;
  void clear_list();
  static const int kListFieldNumber = 5;
  const ::chatserver::ListM& list() const;
  ::chatserver::ListM* mutable_list();
  ::chatserver::ListM* release_list();
  void set_allocated_list(::chatserver::ListM* list);

  TypesCase types_case() const;
  // @@protoc_insertion_point(class_scope:chatserver.oneOfTypes)
 private:
  inline void set_has_logout();
  inline void set_has_login();
  inline void set_has_sendmessage();
  inline void set_has_receivemessage();
  inline void set_has_list();

  inline bool has_types() const;
  void clear_types();
  inline void clear_has_types();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union TypesUnion {
    TypesUnion() {}
    ::chatserver::LogOutM* logout_;
    ::chatserver::LogInM* login_;
    ::chatserver::SendMessageM* sendmessage_;
    ::chatserver::ReceiveMessageM* receivemessage_;
    ::chatserver::ListM* list_;
  } types_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_chatserver_2eproto();
  friend void protobuf_AssignDesc_chatserver_2eproto();
  friend void protobuf_ShutdownFile_chatserver_2eproto();

  void InitAsDefaultInstance();
  static oneOfTypes* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// LogInRequest

// optional string user = 1;
inline void LogInRequest::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogInRequest::user() const {
  // @@protoc_insertion_point(field_get:chatserver.LogInRequest.user)
  return user_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogInRequest::set_user(const ::std::string& value) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chatserver.LogInRequest.user)
}
inline void LogInRequest::set_user(const char* value) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chatserver.LogInRequest.user)
}
inline void LogInRequest::set_user(const char* value, size_t size) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chatserver.LogInRequest.user)
}
inline ::std::string* LogInRequest::mutable_user() {
  
  // @@protoc_insertion_point(field_mutable:chatserver.LogInRequest.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogInRequest::release_user() {
  // @@protoc_insertion_point(field_release:chatserver.LogInRequest.user)
  
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogInRequest::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    
  } else {
    
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:chatserver.LogInRequest.user)
}

// -------------------------------------------------------------------

// LogInReply

// optional string conformation = 1;
inline void LogInReply::clear_conformation() {
  conformation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogInReply::conformation() const {
  // @@protoc_insertion_point(field_get:chatserver.LogInReply.conformation)
  return conformation_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogInReply::set_conformation(const ::std::string& value) {
  
  conformation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chatserver.LogInReply.conformation)
}
inline void LogInReply::set_conformation(const char* value) {
  
  conformation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chatserver.LogInReply.conformation)
}
inline void LogInReply::set_conformation(const char* value, size_t size) {
  
  conformation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chatserver.LogInReply.conformation)
}
inline ::std::string* LogInReply::mutable_conformation() {
  
  // @@protoc_insertion_point(field_mutable:chatserver.LogInReply.conformation)
  return conformation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogInReply::release_conformation() {
  // @@protoc_insertion_point(field_release:chatserver.LogInReply.conformation)
  
  return conformation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogInReply::set_allocated_conformation(::std::string* conformation) {
  if (conformation != NULL) {
    
  } else {
    
  }
  conformation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), conformation);
  // @@protoc_insertion_point(field_set_allocated:chatserver.LogInReply.conformation)
}

// -------------------------------------------------------------------

// LogOutRequest

// optional string user = 1;
inline void LogOutRequest::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogOutRequest::user() const {
  // @@protoc_insertion_point(field_get:chatserver.LogOutRequest.user)
  return user_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogOutRequest::set_user(const ::std::string& value) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chatserver.LogOutRequest.user)
}
inline void LogOutRequest::set_user(const char* value) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chatserver.LogOutRequest.user)
}
inline void LogOutRequest::set_user(const char* value, size_t size) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chatserver.LogOutRequest.user)
}
inline ::std::string* LogOutRequest::mutable_user() {
  
  // @@protoc_insertion_point(field_mutable:chatserver.LogOutRequest.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogOutRequest::release_user() {
  // @@protoc_insertion_point(field_release:chatserver.LogOutRequest.user)
  
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogOutRequest::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    
  } else {
    
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:chatserver.LogOutRequest.user)
}

// -------------------------------------------------------------------

// LogOutReply

// optional string conformation = 1;
inline void LogOutReply::clear_conformation() {
  conformation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogOutReply::conformation() const {
  // @@protoc_insertion_point(field_get:chatserver.LogOutReply.conformation)
  return conformation_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogOutReply::set_conformation(const ::std::string& value) {
  
  conformation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chatserver.LogOutReply.conformation)
}
inline void LogOutReply::set_conformation(const char* value) {
  
  conformation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chatserver.LogOutReply.conformation)
}
inline void LogOutReply::set_conformation(const char* value, size_t size) {
  
  conformation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chatserver.LogOutReply.conformation)
}
inline ::std::string* LogOutReply::mutable_conformation() {
  
  // @@protoc_insertion_point(field_mutable:chatserver.LogOutReply.conformation)
  return conformation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogOutReply::release_conformation() {
  // @@protoc_insertion_point(field_release:chatserver.LogOutReply.conformation)
  
  return conformation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogOutReply::set_allocated_conformation(::std::string* conformation) {
  if (conformation != NULL) {
    
  } else {
    
  }
  conformation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), conformation);
  // @@protoc_insertion_point(field_set_allocated:chatserver.LogOutReply.conformation)
}

// -------------------------------------------------------------------

// SendMessageRequest

// optional string user = 1;
inline void SendMessageRequest::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SendMessageRequest::user() const {
  // @@protoc_insertion_point(field_get:chatserver.SendMessageRequest.user)
  return user_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SendMessageRequest::set_user(const ::std::string& value) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chatserver.SendMessageRequest.user)
}
inline void SendMessageRequest::set_user(const char* value) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chatserver.SendMessageRequest.user)
}
inline void SendMessageRequest::set_user(const char* value, size_t size) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chatserver.SendMessageRequest.user)
}
inline ::std::string* SendMessageRequest::mutable_user() {
  
  // @@protoc_insertion_point(field_mutable:chatserver.SendMessageRequest.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SendMessageRequest::release_user() {
  // @@protoc_insertion_point(field_release:chatserver.SendMessageRequest.user)
  
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SendMessageRequest::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    
  } else {
    
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:chatserver.SendMessageRequest.user)
}

// optional string recipient = 2;
inline void SendMessageRequest::clear_recipient() {
  recipient_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SendMessageRequest::recipient() const {
  // @@protoc_insertion_point(field_get:chatserver.SendMessageRequest.recipient)
  return recipient_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SendMessageRequest::set_recipient(const ::std::string& value) {
  
  recipient_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chatserver.SendMessageRequest.recipient)
}
inline void SendMessageRequest::set_recipient(const char* value) {
  
  recipient_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chatserver.SendMessageRequest.recipient)
}
inline void SendMessageRequest::set_recipient(const char* value, size_t size) {
  
  recipient_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chatserver.SendMessageRequest.recipient)
}
inline ::std::string* SendMessageRequest::mutable_recipient() {
  
  // @@protoc_insertion_point(field_mutable:chatserver.SendMessageRequest.recipient)
  return recipient_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SendMessageRequest::release_recipient() {
  // @@protoc_insertion_point(field_release:chatserver.SendMessageRequest.recipient)
  
  return recipient_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SendMessageRequest::set_allocated_recipient(::std::string* recipient) {
  if (recipient != NULL) {
    
  } else {
    
  }
  recipient_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), recipient);
  // @@protoc_insertion_point(field_set_allocated:chatserver.SendMessageRequest.recipient)
}

// optional string message = 3;
inline void SendMessageRequest::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SendMessageRequest::message() const {
  // @@protoc_insertion_point(field_get:chatserver.SendMessageRequest.message)
  return message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SendMessageRequest::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chatserver.SendMessageRequest.message)
}
inline void SendMessageRequest::set_message(const char* value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chatserver.SendMessageRequest.message)
}
inline void SendMessageRequest::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chatserver.SendMessageRequest.message)
}
inline ::std::string* SendMessageRequest::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:chatserver.SendMessageRequest.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SendMessageRequest::release_message() {
  // @@protoc_insertion_point(field_release:chatserver.SendMessageRequest.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SendMessageRequest::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:chatserver.SendMessageRequest.message)
}

// -------------------------------------------------------------------

// SendMessageReply

// optional string conformation = 1;
inline void SendMessageReply::clear_conformation() {
  conformation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SendMessageReply::conformation() const {
  // @@protoc_insertion_point(field_get:chatserver.SendMessageReply.conformation)
  return conformation_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SendMessageReply::set_conformation(const ::std::string& value) {
  
  conformation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chatserver.SendMessageReply.conformation)
}
inline void SendMessageReply::set_conformation(const char* value) {
  
  conformation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chatserver.SendMessageReply.conformation)
}
inline void SendMessageReply::set_conformation(const char* value, size_t size) {
  
  conformation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chatserver.SendMessageReply.conformation)
}
inline ::std::string* SendMessageReply::mutable_conformation() {
  
  // @@protoc_insertion_point(field_mutable:chatserver.SendMessageReply.conformation)
  return conformation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SendMessageReply::release_conformation() {
  // @@protoc_insertion_point(field_release:chatserver.SendMessageReply.conformation)
  
  return conformation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SendMessageReply::set_allocated_conformation(::std::string* conformation) {
  if (conformation != NULL) {
    
  } else {
    
  }
  conformation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), conformation);
  // @@protoc_insertion_point(field_set_allocated:chatserver.SendMessageReply.conformation)
}

// -------------------------------------------------------------------

// ReceiveMessageRequest

// optional string user = 1;
inline void ReceiveMessageRequest::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReceiveMessageRequest::user() const {
  // @@protoc_insertion_point(field_get:chatserver.ReceiveMessageRequest.user)
  return user_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReceiveMessageRequest::set_user(const ::std::string& value) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chatserver.ReceiveMessageRequest.user)
}
inline void ReceiveMessageRequest::set_user(const char* value) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chatserver.ReceiveMessageRequest.user)
}
inline void ReceiveMessageRequest::set_user(const char* value, size_t size) {
  
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chatserver.ReceiveMessageRequest.user)
}
inline ::std::string* ReceiveMessageRequest::mutable_user() {
  
  // @@protoc_insertion_point(field_mutable:chatserver.ReceiveMessageRequest.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReceiveMessageRequest::release_user() {
  // @@protoc_insertion_point(field_release:chatserver.ReceiveMessageRequest.user)
  
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReceiveMessageRequest::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    
  } else {
    
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:chatserver.ReceiveMessageRequest.user)
}

// -------------------------------------------------------------------

// ReceiveMessageReply

// optional string conformation = 1;
inline void ReceiveMessageReply::clear_conformation() {
  conformation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReceiveMessageReply::conformation() const {
  // @@protoc_insertion_point(field_get:chatserver.ReceiveMessageReply.conformation)
  return conformation_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReceiveMessageReply::set_conformation(const ::std::string& value) {
  
  conformation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chatserver.ReceiveMessageReply.conformation)
}
inline void ReceiveMessageReply::set_conformation(const char* value) {
  
  conformation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chatserver.ReceiveMessageReply.conformation)
}
inline void ReceiveMessageReply::set_conformation(const char* value, size_t size) {
  
  conformation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chatserver.ReceiveMessageReply.conformation)
}
inline ::std::string* ReceiveMessageReply::mutable_conformation() {
  
  // @@protoc_insertion_point(field_mutable:chatserver.ReceiveMessageReply.conformation)
  return conformation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReceiveMessageReply::release_conformation() {
  // @@protoc_insertion_point(field_release:chatserver.ReceiveMessageReply.conformation)
  
  return conformation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReceiveMessageReply::set_allocated_conformation(::std::string* conformation) {
  if (conformation != NULL) {
    
  } else {
    
  }
  conformation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), conformation);
  // @@protoc_insertion_point(field_set_allocated:chatserver.ReceiveMessageReply.conformation)
}

// -------------------------------------------------------------------

// ListRequest

// optional string list = 1;
inline void ListRequest::clear_list() {
  list_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ListRequest::list() const {
  // @@protoc_insertion_point(field_get:chatserver.ListRequest.list)
  return list_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListRequest::set_list(const ::std::string& value) {
  
  list_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chatserver.ListRequest.list)
}
inline void ListRequest::set_list(const char* value) {
  
  list_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chatserver.ListRequest.list)
}
inline void ListRequest::set_list(const char* value, size_t size) {
  
  list_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chatserver.ListRequest.list)
}
inline ::std::string* ListRequest::mutable_list() {
  
  // @@protoc_insertion_point(field_mutable:chatserver.ListRequest.list)
  return list_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListRequest::release_list() {
  // @@protoc_insertion_point(field_release:chatserver.ListRequest.list)
  
  return list_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListRequest::set_allocated_list(::std::string* list) {
  if (list != NULL) {
    
  } else {
    
  }
  list_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), list);
  // @@protoc_insertion_point(field_set_allocated:chatserver.ListRequest.list)
}

// -------------------------------------------------------------------

// ListReply

// optional string list = 1;
inline void ListReply::clear_list() {
  list_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ListReply::list() const {
  // @@protoc_insertion_point(field_get:chatserver.ListReply.list)
  return list_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListReply::set_list(const ::std::string& value) {
  
  list_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chatserver.ListReply.list)
}
inline void ListReply::set_list(const char* value) {
  
  list_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chatserver.ListReply.list)
}
inline void ListReply::set_list(const char* value, size_t size) {
  
  list_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chatserver.ListReply.list)
}
inline ::std::string* ListReply::mutable_list() {
  
  // @@protoc_insertion_point(field_mutable:chatserver.ListReply.list)
  return list_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListReply::release_list() {
  // @@protoc_insertion_point(field_release:chatserver.ListReply.list)
  
  return list_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListReply::set_allocated_list(::std::string* list) {
  if (list != NULL) {
    
  } else {
    
  }
  list_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), list);
  // @@protoc_insertion_point(field_set_allocated:chatserver.ListReply.list)
}

// -------------------------------------------------------------------

// ListM

// optional .chatserver.ListReply reply = 1;
inline bool ListM::has_reply() const {
  return !_is_default_instance_ && reply_ != NULL;
}
inline void ListM::clear_reply() {
  if (GetArenaNoVirtual() == NULL && reply_ != NULL) delete reply_;
  reply_ = NULL;
}
inline const ::chatserver::ListReply& ListM::reply() const {
  // @@protoc_insertion_point(field_get:chatserver.ListM.reply)
  return reply_ != NULL ? *reply_ : *default_instance_->reply_;
}
inline ::chatserver::ListReply* ListM::mutable_reply() {
  
  if (reply_ == NULL) {
    reply_ = new ::chatserver::ListReply;
  }
  // @@protoc_insertion_point(field_mutable:chatserver.ListM.reply)
  return reply_;
}
inline ::chatserver::ListReply* ListM::release_reply() {
  // @@protoc_insertion_point(field_release:chatserver.ListM.reply)
  
  ::chatserver::ListReply* temp = reply_;
  reply_ = NULL;
  return temp;
}
inline void ListM::set_allocated_reply(::chatserver::ListReply* reply) {
  delete reply_;
  reply_ = reply;
  if (reply) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:chatserver.ListM.reply)
}

// optional .chatserver.ListRequest request = 2;
inline bool ListM::has_request() const {
  return !_is_default_instance_ && request_ != NULL;
}
inline void ListM::clear_request() {
  if (GetArenaNoVirtual() == NULL && request_ != NULL) delete request_;
  request_ = NULL;
}
inline const ::chatserver::ListRequest& ListM::request() const {
  // @@protoc_insertion_point(field_get:chatserver.ListM.request)
  return request_ != NULL ? *request_ : *default_instance_->request_;
}
inline ::chatserver::ListRequest* ListM::mutable_request() {
  
  if (request_ == NULL) {
    request_ = new ::chatserver::ListRequest;
  }
  // @@protoc_insertion_point(field_mutable:chatserver.ListM.request)
  return request_;
}
inline ::chatserver::ListRequest* ListM::release_request() {
  // @@protoc_insertion_point(field_release:chatserver.ListM.request)
  
  ::chatserver::ListRequest* temp = request_;
  request_ = NULL;
  return temp;
}
inline void ListM::set_allocated_request(::chatserver::ListRequest* request) {
  delete request_;
  request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:chatserver.ListM.request)
}

// -------------------------------------------------------------------

// ReceiveMessageM

// optional .chatserver.ReceiveMessageReply reply = 1;
inline bool ReceiveMessageM::has_reply() const {
  return !_is_default_instance_ && reply_ != NULL;
}
inline void ReceiveMessageM::clear_reply() {
  if (GetArenaNoVirtual() == NULL && reply_ != NULL) delete reply_;
  reply_ = NULL;
}
inline const ::chatserver::ReceiveMessageReply& ReceiveMessageM::reply() const {
  // @@protoc_insertion_point(field_get:chatserver.ReceiveMessageM.reply)
  return reply_ != NULL ? *reply_ : *default_instance_->reply_;
}
inline ::chatserver::ReceiveMessageReply* ReceiveMessageM::mutable_reply() {
  
  if (reply_ == NULL) {
    reply_ = new ::chatserver::ReceiveMessageReply;
  }
  // @@protoc_insertion_point(field_mutable:chatserver.ReceiveMessageM.reply)
  return reply_;
}
inline ::chatserver::ReceiveMessageReply* ReceiveMessageM::release_reply() {
  // @@protoc_insertion_point(field_release:chatserver.ReceiveMessageM.reply)
  
  ::chatserver::ReceiveMessageReply* temp = reply_;
  reply_ = NULL;
  return temp;
}
inline void ReceiveMessageM::set_allocated_reply(::chatserver::ReceiveMessageReply* reply) {
  delete reply_;
  reply_ = reply;
  if (reply) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:chatserver.ReceiveMessageM.reply)
}

// optional .chatserver.ReceiveMessageRequest request = 2;
inline bool ReceiveMessageM::has_request() const {
  return !_is_default_instance_ && request_ != NULL;
}
inline void ReceiveMessageM::clear_request() {
  if (GetArenaNoVirtual() == NULL && request_ != NULL) delete request_;
  request_ = NULL;
}
inline const ::chatserver::ReceiveMessageRequest& ReceiveMessageM::request() const {
  // @@protoc_insertion_point(field_get:chatserver.ReceiveMessageM.request)
  return request_ != NULL ? *request_ : *default_instance_->request_;
}
inline ::chatserver::ReceiveMessageRequest* ReceiveMessageM::mutable_request() {
  
  if (request_ == NULL) {
    request_ = new ::chatserver::ReceiveMessageRequest;
  }
  // @@protoc_insertion_point(field_mutable:chatserver.ReceiveMessageM.request)
  return request_;
}
inline ::chatserver::ReceiveMessageRequest* ReceiveMessageM::release_request() {
  // @@protoc_insertion_point(field_release:chatserver.ReceiveMessageM.request)
  
  ::chatserver::ReceiveMessageRequest* temp = request_;
  request_ = NULL;
  return temp;
}
inline void ReceiveMessageM::set_allocated_request(::chatserver::ReceiveMessageRequest* request) {
  delete request_;
  request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:chatserver.ReceiveMessageM.request)
}

// -------------------------------------------------------------------

// SendMessageM

// optional .chatserver.SendMessageReply reply = 1;
inline bool SendMessageM::has_reply() const {
  return !_is_default_instance_ && reply_ != NULL;
}
inline void SendMessageM::clear_reply() {
  if (GetArenaNoVirtual() == NULL && reply_ != NULL) delete reply_;
  reply_ = NULL;
}
inline const ::chatserver::SendMessageReply& SendMessageM::reply() const {
  // @@protoc_insertion_point(field_get:chatserver.SendMessageM.reply)
  return reply_ != NULL ? *reply_ : *default_instance_->reply_;
}
inline ::chatserver::SendMessageReply* SendMessageM::mutable_reply() {
  
  if (reply_ == NULL) {
    reply_ = new ::chatserver::SendMessageReply;
  }
  // @@protoc_insertion_point(field_mutable:chatserver.SendMessageM.reply)
  return reply_;
}
inline ::chatserver::SendMessageReply* SendMessageM::release_reply() {
  // @@protoc_insertion_point(field_release:chatserver.SendMessageM.reply)
  
  ::chatserver::SendMessageReply* temp = reply_;
  reply_ = NULL;
  return temp;
}
inline void SendMessageM::set_allocated_reply(::chatserver::SendMessageReply* reply) {
  delete reply_;
  reply_ = reply;
  if (reply) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:chatserver.SendMessageM.reply)
}

// optional .chatserver.SendMessageRequest request = 2;
inline bool SendMessageM::has_request() const {
  return !_is_default_instance_ && request_ != NULL;
}
inline void SendMessageM::clear_request() {
  if (GetArenaNoVirtual() == NULL && request_ != NULL) delete request_;
  request_ = NULL;
}
inline const ::chatserver::SendMessageRequest& SendMessageM::request() const {
  // @@protoc_insertion_point(field_get:chatserver.SendMessageM.request)
  return request_ != NULL ? *request_ : *default_instance_->request_;
}
inline ::chatserver::SendMessageRequest* SendMessageM::mutable_request() {
  
  if (request_ == NULL) {
    request_ = new ::chatserver::SendMessageRequest;
  }
  // @@protoc_insertion_point(field_mutable:chatserver.SendMessageM.request)
  return request_;
}
inline ::chatserver::SendMessageRequest* SendMessageM::release_request() {
  // @@protoc_insertion_point(field_release:chatserver.SendMessageM.request)
  
  ::chatserver::SendMessageRequest* temp = request_;
  request_ = NULL;
  return temp;
}
inline void SendMessageM::set_allocated_request(::chatserver::SendMessageRequest* request) {
  delete request_;
  request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:chatserver.SendMessageM.request)
}

// -------------------------------------------------------------------

// LogInM

// optional .chatserver.LogInReply reply = 1;
inline bool LogInM::has_reply() const {
  return !_is_default_instance_ && reply_ != NULL;
}
inline void LogInM::clear_reply() {
  if (GetArenaNoVirtual() == NULL && reply_ != NULL) delete reply_;
  reply_ = NULL;
}
inline const ::chatserver::LogInReply& LogInM::reply() const {
  // @@protoc_insertion_point(field_get:chatserver.LogInM.reply)
  return reply_ != NULL ? *reply_ : *default_instance_->reply_;
}
inline ::chatserver::LogInReply* LogInM::mutable_reply() {
  
  if (reply_ == NULL) {
    reply_ = new ::chatserver::LogInReply;
  }
  // @@protoc_insertion_point(field_mutable:chatserver.LogInM.reply)
  return reply_;
}
inline ::chatserver::LogInReply* LogInM::release_reply() {
  // @@protoc_insertion_point(field_release:chatserver.LogInM.reply)
  
  ::chatserver::LogInReply* temp = reply_;
  reply_ = NULL;
  return temp;
}
inline void LogInM::set_allocated_reply(::chatserver::LogInReply* reply) {
  delete reply_;
  reply_ = reply;
  if (reply) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:chatserver.LogInM.reply)
}

// optional .chatserver.LogInRequest request = 2;
inline bool LogInM::has_request() const {
  return !_is_default_instance_ && request_ != NULL;
}
inline void LogInM::clear_request() {
  if (GetArenaNoVirtual() == NULL && request_ != NULL) delete request_;
  request_ = NULL;
}
inline const ::chatserver::LogInRequest& LogInM::request() const {
  // @@protoc_insertion_point(field_get:chatserver.LogInM.request)
  return request_ != NULL ? *request_ : *default_instance_->request_;
}
inline ::chatserver::LogInRequest* LogInM::mutable_request() {
  
  if (request_ == NULL) {
    request_ = new ::chatserver::LogInRequest;
  }
  // @@protoc_insertion_point(field_mutable:chatserver.LogInM.request)
  return request_;
}
inline ::chatserver::LogInRequest* LogInM::release_request() {
  // @@protoc_insertion_point(field_release:chatserver.LogInM.request)
  
  ::chatserver::LogInRequest* temp = request_;
  request_ = NULL;
  return temp;
}
inline void LogInM::set_allocated_request(::chatserver::LogInRequest* request) {
  delete request_;
  request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:chatserver.LogInM.request)
}

// -------------------------------------------------------------------

// LogOutM

// optional .chatserver.LogOutReply reply = 1;
inline bool LogOutM::has_reply() const {
  return !_is_default_instance_ && reply_ != NULL;
}
inline void LogOutM::clear_reply() {
  if (GetArenaNoVirtual() == NULL && reply_ != NULL) delete reply_;
  reply_ = NULL;
}
inline const ::chatserver::LogOutReply& LogOutM::reply() const {
  // @@protoc_insertion_point(field_get:chatserver.LogOutM.reply)
  return reply_ != NULL ? *reply_ : *default_instance_->reply_;
}
inline ::chatserver::LogOutReply* LogOutM::mutable_reply() {
  
  if (reply_ == NULL) {
    reply_ = new ::chatserver::LogOutReply;
  }
  // @@protoc_insertion_point(field_mutable:chatserver.LogOutM.reply)
  return reply_;
}
inline ::chatserver::LogOutReply* LogOutM::release_reply() {
  // @@protoc_insertion_point(field_release:chatserver.LogOutM.reply)
  
  ::chatserver::LogOutReply* temp = reply_;
  reply_ = NULL;
  return temp;
}
inline void LogOutM::set_allocated_reply(::chatserver::LogOutReply* reply) {
  delete reply_;
  reply_ = reply;
  if (reply) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:chatserver.LogOutM.reply)
}

// optional .chatserver.LogOutRequest request = 2;
inline bool LogOutM::has_request() const {
  return !_is_default_instance_ && request_ != NULL;
}
inline void LogOutM::clear_request() {
  if (GetArenaNoVirtual() == NULL && request_ != NULL) delete request_;
  request_ = NULL;
}
inline const ::chatserver::LogOutRequest& LogOutM::request() const {
  // @@protoc_insertion_point(field_get:chatserver.LogOutM.request)
  return request_ != NULL ? *request_ : *default_instance_->request_;
}
inline ::chatserver::LogOutRequest* LogOutM::mutable_request() {
  
  if (request_ == NULL) {
    request_ = new ::chatserver::LogOutRequest;
  }
  // @@protoc_insertion_point(field_mutable:chatserver.LogOutM.request)
  return request_;
}
inline ::chatserver::LogOutRequest* LogOutM::release_request() {
  // @@protoc_insertion_point(field_release:chatserver.LogOutM.request)
  
  ::chatserver::LogOutRequest* temp = request_;
  request_ = NULL;
  return temp;
}
inline void LogOutM::set_allocated_request(::chatserver::LogOutRequest* request) {
  delete request_;
  request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:chatserver.LogOutM.request)
}

// -------------------------------------------------------------------

// oneOfTypes

// optional .chatserver.LogOutM logout = 1;
inline bool oneOfTypes::has_logout() const {
  return types_case() == kLogout;
}
inline void oneOfTypes::set_has_logout() {
  _oneof_case_[0] = kLogout;
}
inline void oneOfTypes::clear_logout() {
  if (has_logout()) {
    delete types_.logout_;
    clear_has_types();
  }
}
inline  const ::chatserver::LogOutM& oneOfTypes::logout() const {
  // @@protoc_insertion_point(field_get:chatserver.oneOfTypes.logout)
  return has_logout()
      ? *types_.logout_
      : ::chatserver::LogOutM::default_instance();
}
inline ::chatserver::LogOutM* oneOfTypes::mutable_logout() {
  if (!has_logout()) {
    clear_types();
    set_has_logout();
    types_.logout_ = new ::chatserver::LogOutM;
  }
  // @@protoc_insertion_point(field_mutable:chatserver.oneOfTypes.logout)
  return types_.logout_;
}
inline ::chatserver::LogOutM* oneOfTypes::release_logout() {
  // @@protoc_insertion_point(field_release:chatserver.oneOfTypes.logout)
  if (has_logout()) {
    clear_has_types();
    ::chatserver::LogOutM* temp = types_.logout_;
    types_.logout_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void oneOfTypes::set_allocated_logout(::chatserver::LogOutM* logout) {
  clear_types();
  if (logout) {
    set_has_logout();
    types_.logout_ = logout;
  }
  // @@protoc_insertion_point(field_set_allocated:chatserver.oneOfTypes.logout)
}

// optional .chatserver.LogInM login = 2;
inline bool oneOfTypes::has_login() const {
  return types_case() == kLogin;
}
inline void oneOfTypes::set_has_login() {
  _oneof_case_[0] = kLogin;
}
inline void oneOfTypes::clear_login() {
  if (has_login()) {
    delete types_.login_;
    clear_has_types();
  }
}
inline  const ::chatserver::LogInM& oneOfTypes::login() const {
  // @@protoc_insertion_point(field_get:chatserver.oneOfTypes.login)
  return has_login()
      ? *types_.login_
      : ::chatserver::LogInM::default_instance();
}
inline ::chatserver::LogInM* oneOfTypes::mutable_login() {
  if (!has_login()) {
    clear_types();
    set_has_login();
    types_.login_ = new ::chatserver::LogInM;
  }
  // @@protoc_insertion_point(field_mutable:chatserver.oneOfTypes.login)
  return types_.login_;
}
inline ::chatserver::LogInM* oneOfTypes::release_login() {
  // @@protoc_insertion_point(field_release:chatserver.oneOfTypes.login)
  if (has_login()) {
    clear_has_types();
    ::chatserver::LogInM* temp = types_.login_;
    types_.login_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void oneOfTypes::set_allocated_login(::chatserver::LogInM* login) {
  clear_types();
  if (login) {
    set_has_login();
    types_.login_ = login;
  }
  // @@protoc_insertion_point(field_set_allocated:chatserver.oneOfTypes.login)
}

// optional .chatserver.SendMessageM sendmessage = 3;
inline bool oneOfTypes::has_sendmessage() const {
  return types_case() == kSendmessage;
}
inline void oneOfTypes::set_has_sendmessage() {
  _oneof_case_[0] = kSendmessage;
}
inline void oneOfTypes::clear_sendmessage() {
  if (has_sendmessage()) {
    delete types_.sendmessage_;
    clear_has_types();
  }
}
inline  const ::chatserver::SendMessageM& oneOfTypes::sendmessage() const {
  // @@protoc_insertion_point(field_get:chatserver.oneOfTypes.sendmessage)
  return has_sendmessage()
      ? *types_.sendmessage_
      : ::chatserver::SendMessageM::default_instance();
}
inline ::chatserver::SendMessageM* oneOfTypes::mutable_sendmessage() {
  if (!has_sendmessage()) {
    clear_types();
    set_has_sendmessage();
    types_.sendmessage_ = new ::chatserver::SendMessageM;
  }
  // @@protoc_insertion_point(field_mutable:chatserver.oneOfTypes.sendmessage)
  return types_.sendmessage_;
}
inline ::chatserver::SendMessageM* oneOfTypes::release_sendmessage() {
  // @@protoc_insertion_point(field_release:chatserver.oneOfTypes.sendmessage)
  if (has_sendmessage()) {
    clear_has_types();
    ::chatserver::SendMessageM* temp = types_.sendmessage_;
    types_.sendmessage_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void oneOfTypes::set_allocated_sendmessage(::chatserver::SendMessageM* sendmessage) {
  clear_types();
  if (sendmessage) {
    set_has_sendmessage();
    types_.sendmessage_ = sendmessage;
  }
  // @@protoc_insertion_point(field_set_allocated:chatserver.oneOfTypes.sendmessage)
}

// optional .chatserver.ReceiveMessageM receivemessage = 4;
inline bool oneOfTypes::has_receivemessage() const {
  return types_case() == kReceivemessage;
}
inline void oneOfTypes::set_has_receivemessage() {
  _oneof_case_[0] = kReceivemessage;
}
inline void oneOfTypes::clear_receivemessage() {
  if (has_receivemessage()) {
    delete types_.receivemessage_;
    clear_has_types();
  }
}
inline  const ::chatserver::ReceiveMessageM& oneOfTypes::receivemessage() const {
  // @@protoc_insertion_point(field_get:chatserver.oneOfTypes.receivemessage)
  return has_receivemessage()
      ? *types_.receivemessage_
      : ::chatserver::ReceiveMessageM::default_instance();
}
inline ::chatserver::ReceiveMessageM* oneOfTypes::mutable_receivemessage() {
  if (!has_receivemessage()) {
    clear_types();
    set_has_receivemessage();
    types_.receivemessage_ = new ::chatserver::ReceiveMessageM;
  }
  // @@protoc_insertion_point(field_mutable:chatserver.oneOfTypes.receivemessage)
  return types_.receivemessage_;
}
inline ::chatserver::ReceiveMessageM* oneOfTypes::release_receivemessage() {
  // @@protoc_insertion_point(field_release:chatserver.oneOfTypes.receivemessage)
  if (has_receivemessage()) {
    clear_has_types();
    ::chatserver::ReceiveMessageM* temp = types_.receivemessage_;
    types_.receivemessage_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void oneOfTypes::set_allocated_receivemessage(::chatserver::ReceiveMessageM* receivemessage) {
  clear_types();
  if (receivemessage) {
    set_has_receivemessage();
    types_.receivemessage_ = receivemessage;
  }
  // @@protoc_insertion_point(field_set_allocated:chatserver.oneOfTypes.receivemessage)
}

// optional .chatserver.ListM list = 5;
inline bool oneOfTypes::has_list() const {
  return types_case() == kList;
}
inline void oneOfTypes::set_has_list() {
  _oneof_case_[0] = kList;
}
inline void oneOfTypes::clear_list() {
  if (has_list()) {
    delete types_.list_;
    clear_has_types();
  }
}
inline  const ::chatserver::ListM& oneOfTypes::list() const {
  // @@protoc_insertion_point(field_get:chatserver.oneOfTypes.list)
  return has_list()
      ? *types_.list_
      : ::chatserver::ListM::default_instance();
}
inline ::chatserver::ListM* oneOfTypes::mutable_list() {
  if (!has_list()) {
    clear_types();
    set_has_list();
    types_.list_ = new ::chatserver::ListM;
  }
  // @@protoc_insertion_point(field_mutable:chatserver.oneOfTypes.list)
  return types_.list_;
}
inline ::chatserver::ListM* oneOfTypes::release_list() {
  // @@protoc_insertion_point(field_release:chatserver.oneOfTypes.list)
  if (has_list()) {
    clear_has_types();
    ::chatserver::ListM* temp = types_.list_;
    types_.list_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void oneOfTypes::set_allocated_list(::chatserver::ListM* list) {
  clear_types();
  if (list) {
    set_has_list();
    types_.list_ = list;
  }
  // @@protoc_insertion_point(field_set_allocated:chatserver.oneOfTypes.list)
}

inline bool oneOfTypes::has_types() const {
  return types_case() != TYPES_NOT_SET;
}
inline void oneOfTypes::clear_has_types() {
  _oneof_case_[0] = TYPES_NOT_SET;
}
inline oneOfTypes::TypesCase oneOfTypes::types_case() const {
  return oneOfTypes::TypesCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace chatserver

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_chatserver_2eproto__INCLUDED
